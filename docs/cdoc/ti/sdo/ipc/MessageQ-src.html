<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><title>module ti.sdo.ipc.MessageQ</title>
<meta name="googlebot" content="noindex,nofollow">
<link rel="stylesheet" type="text/css" href="../../../src.css"/>
</head>
<body>
<pre class=src>
     1    <span class="comment">/* --COPYRIGHT--,BSD
</span>     2    <span class="comment"> * Copyright (c) $(CPYYEAR), Texas Instruments Incorporated
</span>     3    <span class="comment"> * All rights reserved.
</span>     4    <span class="comment"> *
</span>     5    <span class="comment"> * Redistribution and use in source and binary forms, with or without
</span>     6    <span class="comment"> * modification, are permitted provided that the following conditions
</span>     7    <span class="comment"> * are met:
</span>     8    <span class="comment"> *
</span>     9    <span class="comment"> * *  Redistributions of source code must retain the above copyright
</span>    10    <span class="comment"> *    notice, this list of conditions and the following disclaimer.
</span>    11    <span class="comment"> *
</span>    12    <span class="comment"> * *  Redistributions in binary form must reproduce the above copyright
</span>    13    <span class="comment"> *    notice, this list of conditions and the following disclaimer in the
</span>    14    <span class="comment"> *    documentation and/or other materials provided with the distribution.
</span>    15    <span class="comment"> *
</span>    16    <span class="comment"> * *  Neither the name of Texas Instruments Incorporated nor the names of
</span>    17    <span class="comment"> *    its contributors may be used to endorse or promote products derived
</span>    18    <span class="comment"> *    from this software without specific prior written permission.
</span>    19    <span class="comment"> *
</span>    20    <span class="comment"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
</span>    21    <span class="comment"> * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
</span>    22    <span class="comment"> * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
</span>    23    <span class="comment"> * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
</span>    24    <span class="comment"> * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
</span>    25    <span class="comment"> * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
</span>    26    <span class="comment"> * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
</span>    27    <span class="comment"> * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
</span>    28    <span class="comment"> * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
</span>    29    <span class="comment"> * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
</span>    30    <span class="comment"> * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
</span>    31    <span class="comment"> * --/COPYRIGHT--*/</span>
    32    <span class="comment">/*
</span>    33    <span class="comment"> *  ======== MessageQ.xdc ========
</span>    34    <span class="comment"> *
</span>    35    <span class="comment"> *! Revision History
</span>    36    <span class="comment"> *! ================
</span>    37    <span class="comment"> *! 26-Feb-2010 skp     Fixed SDOCM00067176 (QueueId defined in MessageQ.xdc)
</span>    38    <span class="comment"> *! 16-Feb-2010 jv      Fix a couple of issues from SDOCM00066822 here.
</span>    39    <span class="comment"> *! 04-Feb-2010 skp     Removed 'name' from Instance state
</span>    40    <span class="comment"> *! 07-Aug-2008 skp     cdoc cleanup
</span>    41    <span class="comment"> *! 04-Jun-2008 agd     cdoc cleanup
</span>    42    <span class="comment"> *! 14-Dec-2007 connell updated call context table
</span>    43    <span class="comment"> *! 06-Jun-2007 toddm   nodoc'd the whole module. Not supported in BIOS 6.0.
</span>    44    <span class="comment"> *! 11-May-2007 agd     Addressed SDSCM00016616
</span>    45    <span class="comment"> *! 16-Apr-2007 cmcc    Added calling context table
</span>    46    <span class="comment"> *! 29-Sep-2006 toddm   Added error block into MessageQ_alloc
</span>    47    <span class="comment"> *! 10-Apr-2006 toddm   created
</span>    48    <span class="comment"> */</span>
    49    
    50    <span class=key>package</span> ti.sdo.ipc;
    51    
    52    import xdc.runtime.IHeap;
    53    import xdc.runtime.Assert;
    54    import xdc.runtime.Error;
    55    import xdc.runtime.Diags;
    56    import xdc.runtime.Log;
    57    import xdc.runtime.IGateProvider;
    58    import xdc.runtime.knl.ISync;
    59    
    60    import ti.sysbios.syncs.SyncSem;
    61    
    62    import ti.sdo.ipc.interfaces.IMessageQTransport;
    63    import ti.sdo.utils.NameServer;
    64    import ti.sdo.utils.List;
    65    
    66    import xdc.rov.ViewInfo;
    67    
    68    <span class="xdoc">/*!
</span>    69    <span class="xdoc"> *  ======== MessageQ ======== 
</span>    70    <span class="xdoc"> *  Message-passing with queuing
</span>    71    <span class="xdoc"> *
</span>    72    <span class="xdoc"> *  The MessageQ module supports the structured sending and receiving of 
</span>    73    <span class="xdoc"> *  variable length messages. This module can be used for homogeneous
</span>    74    <span class="xdoc"> *  (DSP to DSP)  or heterogeneous (Arm to DSP) multi-processor messaging. 
</span>    75    <span class="xdoc"> * 
</span>    76    <span class="xdoc"> *  MessageQ provides more sophisticated messaging than other modules. It is
</span>    77    <span class="xdoc"> *  typically used for complex situations such as multi-processor messaging. 
</span>    78    <span class="xdoc"> * 
</span>    79    <span class="xdoc"> *  The following are key features of the MessageQ module:
</span>    80    <span class="xdoc"> *  <b>@p(blist)</b>
</span>    81    <span class="xdoc"> *  -Writers and readers can be relocated to another processor with no
</span>    82    <span class="xdoc"> *   runtime code changes.
</span>    83    <span class="xdoc"> *  -Timeouts are allowed when receiving messages.
</span>    84    <span class="xdoc"> *  -Readers can determine the writer and reply back.
</span>    85    <span class="xdoc"> *  -Receiving a message is deterministic when the timeout is zero.
</span>    86    <span class="xdoc"> *  -Messages can reside on any message queue.
</span>    87    <span class="xdoc"> *  -Supports zero-copy transfers.
</span>    88    <span class="xdoc"> *  -Can send and receive from any type of thread.
</span>    89    <span class="xdoc"> *  -Notification mechanism is specified by application.
</span>    90    <span class="xdoc"> *  -Allows QoS (quality of service) on message buffer pools. For example,
</span>    91    <span class="xdoc"> *   using specific buffer pools for specific message queues.
</span>    92    <span class="xdoc"> *  <b>@p</b>
</span>    93    <span class="xdoc"> *
</span>    94    <span class="xdoc"> *  Messages are sent and received by being placed on and removed from a
</span>    95    <span class="xdoc"> *  message queue. A reader is a thread that gets (reads) messages from a
</span>    96    <span class="xdoc"> *  message queue. A writer is a thread that puts (writes) a message to a
</span>    97    <span class="xdoc"> *  message queue. Each message queue has one reader and can have many writers.
</span>    98    <span class="xdoc"> *  A thread may read from or write to multiple message queues.
</span>    99    <span class="xdoc"> *
</span>   100    <span class="xdoc"> *  Conceptually, the reader thread owns a message queue. The reader thread
</span>   101    <span class="xdoc"> *  creates a message queue. The writer threads open a created message queue
</span>   102    <span class="xdoc"> *  to get access to them.
</span>   103    <span class="xdoc"> *
</span>   104    <span class="xdoc"> *  Message queues are identified by a system-wide unique name. Internally, 
</span>   105    <span class="xdoc"> *  MessageQ uses the {<b>@link</b> ti.sdo.utils.NameServer} module for managing 
</span>   106    <span class="xdoc"> *  these names. The names are used for opening a message queue.
</span>   107    <span class="xdoc"> * 
</span>   108    <span class="xdoc"> *  Messages must be allocated from the MessageQ module. Once a message is
</span>   109    <span class="xdoc"> *  allocated, it can be sent to any message queue. Once a message is sent, the
</span>   110    <span class="xdoc"> *  writer loses ownership of the message and should not attempt to modify the
</span>   111    <span class="xdoc"> *  message. Once the reader receives the message, it owns the message. It
</span>   112    <span class="xdoc"> *  may either free the message or re-use the message.
</span>   113    <span class="xdoc"> *
</span>   114    <span class="xdoc"> *  Messages in a message queue can be of variable length. The only
</span>   115    <span class="xdoc"> *  requirement is that the first field in the definition of a message must be a
</span>   116    <span class="xdoc"> *  {<b>@link</b> #MsgHeader} structure. For example:
</span>   117    <span class="xdoc"> *  <b>@p(code)</b>
</span>   118    <span class="xdoc"> *  typedef struct MyMsg {
</span>   119    <span class="xdoc"> *      MessageQ_MsgHeader header;
</span>   120    <span class="xdoc"> *      ...
</span>   121    <span class="xdoc"> *  } MyMsg;
</span>   122    <span class="xdoc"> *  <b>@p</b>
</span>   123    <span class="xdoc"> *
</span>   124    <span class="xdoc"> *  The MessageQ API uses the MessageQ_MsgHeader internally. Your application
</span>   125    <span class="xdoc"> *  should not modify or directly access the fields in the MessageQ_MsgHeader.
</span>   126    <span class="xdoc"> *
</span>   127    <span class="xdoc"> *  All messages sent via the MessageQ module must be allocated from a 
</span>   128    <span class="xdoc"> *  {<b>@link</b> xdc.runtime.IHeap} implementation. The heap can also be used for
</span>   129    <span class="xdoc"> *  other memory allocation not related to MessageQ.
</span>   130    <span class="xdoc"> *
</span>   131    <span class="xdoc"> *  An application can use multiple heaps. The purpose of having multiple
</span>   132    <span class="xdoc"> *  heaps is to allow an application to regulate its message usage. For
</span>   133    <span class="xdoc"> *  example, an application can allocate critical messages from one heap of fast
</span>   134    <span class="xdoc"> *  on-chip memory and non-critical messages from another heap of slower
</span>   135    <span class="xdoc"> *  external memory.
</span>   136    <span class="xdoc"> *
</span>   137    <span class="xdoc"> *  The {<b>@link</b> #registerHeap} and {<b>@link</b> #registerHeapMeta} are APIs used to
</span>   138    <span class="xdoc"> *  assign a MessageQ heapId to a heap. When allocating a message, the heapId
</span>   139    <span class="xdoc"> *  is used, not the heap handle. This heapId is actually placed into the 
</span>   140    <span class="xdoc"> *  message (part of the {<b>@link</b> #MsgHeader}). Care must be taken when assigning
</span>   141    <span class="xdoc"> *  heapIds. Refer to the {<b>@link</b> #registerHeap} and {<b>@link</b> #registerHeapMeta}
</span>   142    <span class="xdoc"> *  descriptions for more details.
</span>   143    <span class="xdoc"> *
</span>   144    <span class="xdoc"> *  MessageQ also supports the usage of messages that are not allocated via the
</span>   145    <span class="xdoc"> *  {<b>@link</b> #alloc} function. Please refer to the {<b>@link</b> #staticMsgInit}
</span>   146    <span class="xdoc"> *  function description for more details.
</span>   147    <span class="xdoc"> *
</span>   148    <span class="xdoc"> *  MessageQ supports reads/writes of different thread models. This is
</span>   149    <span class="xdoc"> *  accomplished by having the creator of the message queue specify a 
</span>   150    <span class="xdoc"> *  {<b>@link</b> xdc.runtime.knl.ISync#Object} via the {<b>@link</b> #synchronizer}
</span>   151    <span class="xdoc"> *  configuration parameter. The {<b>@link</b> xdc.runtime.knl.ISync#signal} 
</span>   152    <span class="xdoc"> *  portion of the ISync instance is called whenever the {<b>@link</b> #put}
</span>   153    <span class="xdoc"> *  is called. The {<b>@link</b> xdc.runtime.knl.ISync#wait} portion is 
</span>   154    <span class="xdoc"> *  called in the {<b>@link</b> #get} if and only if there are no messages.
</span>   155    <span class="xdoc"> *
</span>   156    <span class="xdoc"> *  Since ISyncs are binary, the reader must drain the message queue of all
</span>   157    <span class="xdoc"> *  messages before waiting for another signal. For example, if the reader 
</span>   158    <span class="xdoc"> *  was a SYSBIOS Swi, the {<b>@link</b> xdc.runtime.knl.ISync} instance 
</span>   159    <span class="xdoc"> *  could be a SyncSwi. If a {<b>@link</b> #put} was called, the Swi_post() would 
</span>   160    <span class="xdoc"> *  be called. The Swi would run and it must call {<b>@link</b> #get} until no 
</span>   161    <span class="xdoc"> *  messages are returned.
</span>   162    <span class="xdoc"> * 
</span>   163    <span class="xdoc"> *  In a multiple processor system, MessageQ communicates to other
</span>   164    <span class="xdoc"> *  processors via {<b>@link</b> ti.sdo.ipc.interfaces.IMessageQTransport} instances.  
</span>   165    <span class="xdoc"> *  MessageQ supports a high priority and a normal priority transport between 
</span>   166    <span class="xdoc"> *  any two processors. The IMessageQTransport instances are created via the
</span>   167    <span class="xdoc"> *  {<b>@link</b> #SetupTransportProxy}. The instances are responsible for
</span>   168    <span class="xdoc"> *  registering themselves with MessageQ. This is accomplished via the
</span>   169    <span class="xdoc"> * {<b>@link</b> #registerTransport} function.
</span>   170    <span class="xdoc"> */</span>
   171    
   172    @ModuleStartup 
   173    @InstanceInitError
   174    @InstanceFinalize
   175    
   176    <span class=key>module</span> MessageQ
   177    {
   178        <span class="xdoc">/*!
</span>   179    <span class="xdoc">     *  ======== QueuesView ========
</span>   180    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   181    <span class="xdoc">     */</span>
   182        <span class=key>metaonly</span> <span class=key>struct</span> QueuesView {
   183            String  name;
   184            UInt    queueId;
   185        }
   186        
   187        <span class="xdoc">/*!
</span>   188    <span class="xdoc">     *  ======== MessagesView ========
</span>   189    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   190    <span class="xdoc">     */</span>
   191        <span class=key>metaonly</span> <span class=key>struct</span> MessagesView {
   192            Int          seqNum;
   193            Int          msgSize;
   194            String       priority;
   195            String       srcProc;        
   196            String       replyProc;
   197            String       replyId;
   198            Int          msgId;          
   199            String       heap;
   200            Bool         traceEnabled;
   201            Int          version;
   202        }
   203    
   204        <span class="xdoc">/*!
</span>   205    <span class="xdoc">     *  ======== ModuleView ========
</span>   206    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   207    <span class="xdoc">     */</span>
   208        <span class=key>metaonly</span> <span class=key>struct</span> ModuleView {        
   209            String               heaps[];        
   210            String               gate;
   211            UInt16               nextSeqNum;
   212        }
   213        
   214        <span class="xdoc">/*!
</span>   215    <span class="xdoc">     *  ======== rovViewInfo ========
</span>   216    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   217    <span class="xdoc">     */</span>
   218        @Facet
   219        <span class=key>metaonly</span> <span class=key>config</span> xdc.rov.ViewInfo.Instance rovViewInfo = 
   220            xdc.rov.ViewInfo.create({
   221                viewMap: [
   222                    [<span class="string">'Queues'</span>,
   223                        {
   224                            type: xdc.rov.ViewInfo.INSTANCE,
   225                            viewInitFxn: <span class="string">'viewInitQueues'</span>,
   226                            structName: <span class="string">'QueuesView'</span>
   227                        }
   228                    ],
   229                    [<span class="string">'Messages'</span>, 
   230                        {
   231                            type: xdc.rov.ViewInfo.INSTANCE_DATA,
   232                            viewInitFxn: <span class="string">'viewInitMessages'</span>,
   233                            structName: <span class="string">'MessagesView'</span>
   234                        }
   235                    ],
   236                    [<span class="string">'Module'</span>, 
   237                        {
   238                            type: xdc.rov.ViewInfo.MODULE,
   239                            viewInitFxn: <span class="string">'viewInitModule'</span>,
   240                            structName: <span class="string">'ModuleView'</span>
   241                        }
   242                    ]
   243                ]
   244            });
   245        
   246        <span class="xdoc">/*!
</span>   247    <span class="xdoc">     *  ======== LM_setTrace ========
</span>   248    <span class="xdoc">     *  Logged when setting the trace flag on a message
</span>   249    <span class="xdoc">     *
</span>   250    <span class="xdoc">     *  This is logged when tracing on a message is set via
</span>   251    <span class="xdoc">     *  {<b>@link</b> #setMsgTrace}.
</span>   252    <span class="xdoc">     */</span>
   253        <span class=key>config</span> Log.Event LM_setTrace = {
   254            mask: Diags.USER1,
   255            msg: <span class="string">"LM_setTrace: Message 0x%x (seqNum = %d, srcProc = %d) traceFlag = %d"</span>
   256        };
   257        
   258        <span class="xdoc">/*!
</span>   259    <span class="xdoc">     *  ======== LM_alloc ========
</span>   260    <span class="xdoc">     *  Logged when allocating a message
</span>   261    <span class="xdoc">     *
</span>   262    <span class="xdoc">     *  When the {<b>@link</b> #traceFlag} is true, all message allocations
</span>   263    <span class="xdoc">     *  are logged.
</span>   264    <span class="xdoc">     */</span>
   265        <span class=key>config</span> Log.Event LM_alloc = {
   266            mask: Diags.USER1,
   267            msg: <span class="string">"LM_alloc: Message 0x%x (seqNum = %d, srcProc = %d) was allocated"</span>
   268        };
   269        
   270        <span class="xdoc">/*!
</span>   271    <span class="xdoc">     *  ======== LM_staticMsgInit ========
</span>   272    <span class="xdoc">     *  Logged when statically initializing a message
</span>   273    <span class="xdoc">     *
</span>   274    <span class="xdoc">     *  When the {<b>@link</b> #traceFlag} is true, all messages that
</span>   275    <span class="xdoc">     *  are statically initialized via {<b>@link</b> #staticMsgInit} are logged.
</span>   276    <span class="xdoc">     */</span>
   277        <span class=key>config</span> Log.Event LM_staticMsgInit = {
   278            mask: Diags.USER1,
   279            msg: <span class="string">"LM_staticMsgInit: Message 0x%x (seqNum = %d, srcProc = %d) was set in MessageQ_staticMsgInit"</span>
   280        };
   281        
   282        <span class="xdoc">/*!
</span>   283    <span class="xdoc">     *  ======== LM_free ========
</span>   284    <span class="xdoc">     *  Logged when freeing a message
</span>   285    <span class="xdoc">     *
</span>   286    <span class="xdoc">     *  When the {<b>@link</b> #traceFlag} is true, all freeing of messages
</span>   287    <span class="xdoc">     *  are logged. If an individual message's tracing was enabled 
</span>   288    <span class="xdoc">     *  via {<b>@link</b> #setMsgTrace}, the MessageQ_free is also logged.
</span>   289    <span class="xdoc">     */</span>
   290        <span class=key>config</span> Log.Event LM_free = {
   291            mask: Diags.USER1,
   292            msg: <span class="string">"LM_free: Message 0x%x (seqNum = %d, srcProc = %d) was freed"</span>
   293        };
   294        
   295        <span class="xdoc">/*!
</span>   296    <span class="xdoc">     *  ======== LM_putLocal ========
</span>   297    <span class="xdoc">     *  Logged when a message is placed onto a local queue
</span>   298    <span class="xdoc">     *
</span>   299    <span class="xdoc">     *  When the {<b>@link</b> #traceFlag} is true, all putting of messages
</span>   300    <span class="xdoc">     *  are logged. If an individual message's tracing was enabled 
</span>   301    <span class="xdoc">     *  via {<b>@link</b> #setMsgTrace}, the MessageQ_put is also logged.
</span>   302    <span class="xdoc">     */</span>
   303        <span class=key>config</span> Log.Event LM_putLocal = {
   304            mask: Diags.USER1,
   305            msg: <span class="string">"LM_putLocal: Message 0x%x (seqNum = %d, srcProc = %d) was placed onto queue 0x%x"</span>
   306        };
   307        
   308        <span class="xdoc">/*!
</span>   309    <span class="xdoc">     *  ======== LM_putRemote ========
</span>   310    <span class="xdoc">     *  Logged when a message is given to a transport
</span>   311    <span class="xdoc">     *
</span>   312    <span class="xdoc">     *  When the {<b>@link</b> #traceFlag} is true, all putting of messages
</span>   313    <span class="xdoc">     *  to a transport are logged. If an individual message's tracing
</span>   314    <span class="xdoc">     *  was enabled  via {<b>@link</b> #setMsgTrace}, the MessageQ_put is 
</span>   315    <span class="xdoc">     *  also logged.
</span>   316    <span class="xdoc">     */</span>
   317        <span class=key>config</span> Log.Event LM_putRemote = {
   318            mask: Diags.USER1,
   319            msg: <span class="string">"LM_putRemote: Message 0x%x (seqNum = %d, srcProc = %d) was given to processor %d transport"</span>
   320        };
   321        
   322        <span class="xdoc">/*!
</span>   323    <span class="xdoc">     *  ======== LM_rcvByTransport ========
</span>   324    <span class="xdoc">     *  Logged when a transport receives an incoming message
</span>   325    <span class="xdoc">     *
</span>   326    <span class="xdoc">     *  When the {<b>@link</b> #traceFlag} is true, all incoming messages
</span>   327    <span class="xdoc">     *  are logged. If an individual message's tracing
</span>   328    <span class="xdoc">     *  was enabled  via {<b>@link</b> #setMsgTrace}, the receiving of a message is 
</span>   329    <span class="xdoc">     *  also logged.
</span>   330    <span class="xdoc">     */</span>
   331        <span class=key>config</span> Log.Event LM_rcvByTransport = {
   332            mask: Diags.USER1,
   333            msg: <span class="string">"LM_rcvByTransport: Message 0x%x (seqNum = %d, srcProc = %d) was received"</span>
   334        };
   335        
   336        <span class="xdoc">/*!
</span>   337    <span class="xdoc">     *  ======== LM_get ========
</span>   338    <span class="xdoc">     *  Logged when a message is received off the queue
</span>   339    <span class="xdoc">     *
</span>   340    <span class="xdoc">     *  When the {<b>@link</b> #traceFlag} is true, all getting of messages
</span>   341    <span class="xdoc">     *  are logged. If an individual message's tracing
</span>   342    <span class="xdoc">     *  was enabled  via {<b>@link</b> #setMsgTrace}, the MessageQ_get is 
</span>   343    <span class="xdoc">     *  also logged.
</span>   344    <span class="xdoc">     */</span>
   345        <span class=key>config</span> Log.Event LM_get = {
   346            mask: Diags.USER1,
   347            msg: <span class="string">"LM_get: Message 0x%x (seqNum = %d, srcProc = %d) was received by queue 0x%x"</span>
   348        };
   349        
   350        <span class="xdoc">/*! MessageQ ID */</span>
   351        <span class=key>typedef</span> UInt32 QueueId;
   352        
   353        <span class="xdoc">/*!
</span>   354    <span class="xdoc">     *  ======== SetupTransportProxy ========
</span>   355    <span class="xdoc">     *  MessageQ transport setup proxy
</span>   356    <span class="xdoc">     */</span>
   357        <span class=key>proxy</span> SetupTransportProxy <span class=key>inherits</span> ti.sdo.ipc.interfaces.ITransportSetup;
   358        
   359        <span class="xdoc">/*!
</span>   360    <span class="xdoc">     *  Message priority values. These must match the values defined in
</span>   361    <span class="xdoc">     *  ti/ipc/MessageQ.h but are needed here for ROV.
</span>   362    <span class="xdoc">     */</span>
   363        <span class=key>const</span> UInt NORMALPRI   = 0;
   364        <span class=key>const</span> UInt HIGHPRI     = 1;
   365        <span class=key>const</span> UInt RESERVEDPRI = 2;
   366        <span class=key>const</span> UInt URGENTPRI   = 3;
   367        
   368        <span class="xdoc">/*!
</span>   369    <span class="xdoc">     *  Assert raised when calling API with wrong handle
</span>   370    <span class="xdoc">     *
</span>   371    <span class="xdoc">     *  Some APIs can only be called with an opened handle (e.g. 
</span>   372    <span class="xdoc">     *  {<b>@link</b> #close}. Some can only be called with a created handle
</span>   373    <span class="xdoc">     *  (e.g. {<b>@link</b> #get}).
</span>   374    <span class="xdoc">     */</span>
   375        <span class=key>config</span> Assert.Id A_invalidContext  = {
   376            msg: <span class="string">"A_invalidContext: Cannot call with an open/create handle"</span>
   377        };
   378                
   379        <span class="xdoc">/*!
</span>   380    <span class="xdoc">     *  Assert raised when attempting to free a static message
</span>   381    <span class="xdoc">     */</span>
   382        <span class=key>config</span> Assert.Id A_cannotFreeStaticMsg  = {
   383            msg: <span class="string">"A_cannotFreeStaticMsg: Cannot call MessageQ_free with static msg"</span>
   384        };
   385        
   386        <span class="xdoc">/*!
</span>   387    <span class="xdoc">     *  Assert raised when an invalid message is supplied
</span>   388    <span class="xdoc">     */</span>
   389        <span class=key>config</span> Assert.Id A_invalidMsg  = {
   390            msg: <span class="string">"A_invalidMsg: Invalid message"</span>
   391        };
   392    
   393        <span class="xdoc">/*!
</span>   394    <span class="xdoc">     *  Assert raised when an invalid queueId is supplied
</span>   395    <span class="xdoc">     */</span>
   396        <span class=key>config</span> Assert.Id A_invalidQueueId  = {
   397            msg: <span class="string">"A_invalidQueueId: Invalid queueId is used"</span>
   398        };
   399    
   400        <span class="xdoc">/*!
</span>   401    <span class="xdoc">     *  Assert raised when using an invalid heapId
</span>   402    <span class="xdoc">     */</span>
   403        <span class=key>config</span> Assert.Id A_heapIdInvalid  = {
   404            msg: <span class="string">"A_heapIdInvalid: heapId is invalid"</span>
   405        };
   406        
   407        <span class="xdoc">/*!
</span>   408    <span class="xdoc">     *  Assert raised when using an invalid procId
</span>   409    <span class="xdoc">     */</span>
   410        <span class=key>config</span> Assert.Id A_procIdInvalid  = {
   411            msg: <span class="string">"A_procIdInvalid: procId is invalid"</span>
   412        };
   413        
   414        <span class="xdoc">/*!
</span>   415    <span class="xdoc">     *  Assert raised for an invalid MessageQ object 
</span>   416    <span class="xdoc">     */</span>
   417        <span class=key>config</span> Assert.Id A_invalidObj  = {
   418            msg: <span class="string">"A_invalidObj: an invalid obj is used"</span>
   419        };
   420    
   421        <span class="xdoc">/*!
</span>   422    <span class="xdoc">     *  Assert raised for an invalid parameter 
</span>   423    <span class="xdoc">     */</span>
   424        <span class=key>config</span> Assert.Id A_invalidParam  = {
   425            msg: <span class="string">"A_invalidParam: an invalid parameter was passed in"</span>
   426        };
   427    
   428        <span class="xdoc">/*!
</span>   429    <span class="xdoc">     *  Assert raised when attempting to send a message to a core
</span>   430    <span class="xdoc">     *  where a transport has not been registered.
</span>   431    <span class="xdoc">     */</span>
   432        <span class=key>config</span> Assert.Id A_unregisteredTransport  = {
   433            msg: <span class="string">"A_unregisteredTransport: transport is not registered"</span>
   434        };
   435        
   436        <span class="xdoc">/*!
</span>   437    <span class="xdoc">     *  Assert raised when attempting to unblock a remote MessageQ or one that
</span>   438    <span class="xdoc">     *  has been configured with a non-blocking synchronizer
</span>   439    <span class="xdoc">     */</span>
   440        <span class=key>config</span> Assert.Id A_invalidUnblock  = {
   441            msg: <span class="string">"A_invalidUnblock: Trying to unblock a remote MessageQ or a queue with non-blocking synchronizer"</span>
   442        };
   443        
   444        <span class="xdoc">/*!
</span>   445    <span class="xdoc">     *  Error raised if all the message queue objects are taken
</span>   446    <span class="xdoc">     */</span>
   447        <span class=key>config</span> Error.Id E_maxReached  = {
   448            msg: <span class="string">"E_maxReached: All objects in use. MessageQ.maxRuntimeEntries is %d"</span>
   449        };
   450        
   451        <span class="xdoc">/*!
</span>   452    <span class="xdoc">     *  Error raised when heapId has not been registered
</span>   453    <span class="xdoc">     */</span>
   454        <span class=key>config</span> Error.Id E_unregisterHeapId  = {
   455            msg: <span class="string">"E_unregisterHeapId: Heap id %d not registered"</span>
   456        };
   457    
   458        <span class="xdoc">/*!
</span>   459    <span class="xdoc">     *  Error raised in a create call when a name fails to be added
</span>   460    <span class="xdoc">     *  to the NameServer table.  This can be because the name already
</span>   461    <span class="xdoc">     *  exists, the table has reached its max length, or out of memory.
</span>   462    <span class="xdoc">     */</span>
   463        <span class=key>config</span> Error.Id E_nameFailed  = {
   464            msg: <span class="string">"E_nameFailed: '%s' name failed to be added to NameServer"</span>
   465        };
   466    
   467        <span class="xdoc">/*!
</span>   468    <span class="xdoc">     *  Trace setting
</span>   469    <span class="xdoc">     *
</span>   470    <span class="xdoc">     *  This flag allows the configuration of the default module trace 
</span>   471    <span class="xdoc">     *  settings.     
</span>   472    <span class="xdoc">     */</span>
   473        <span class=key>config</span> Bool traceFlag = <span class=key>false</span>;    
   474        
   475        <span class="xdoc">/*!
</span>   476    <span class="xdoc">     *  Number of heapIds in the system
</span>   477    <span class="xdoc">     *
</span>   478    <span class="xdoc">     *  This allows MessageQ to pre-allocate the heaps table.
</span>   479    <span class="xdoc">     *  The heaps table is used when registering heaps.
</span>   480    <span class="xdoc">     *
</span>   481    <span class="xdoc">     *  There is no default heap, so unless the system is only using
</span>   482    <span class="xdoc">     *  {<b>@link</b> #staticMsgInit}, the application must register a heap.
</span>   483    <span class="xdoc">     */</span>
   484        <span class=key>config</span> UInt16 numHeaps = 8;
   485        
   486        <span class="xdoc">/*! 
</span>   487    <span class="xdoc">     *  Maximum number of MessageQs that can be dynamically created
</span>   488    <span class="xdoc">     */</span>
   489        <span class=key>config</span> UInt maxRuntimeEntries = NameServer.ALLOWGROWTH;
   490        
   491        <span class="xdoc">/*! 
</span>   492    <span class="xdoc">     *  Gate used to make the name table thread safe
</span>   493    <span class="xdoc">     *
</span>   494    <span class="xdoc">     *  This gate is used when accessing the name table during 
</span>   495    <span class="xdoc">     *  a {<b>@link</b> #create}, {<b>@link</b> #delete}, and {<b>@link</b> #open}.
</span>   496    <span class="xdoc">     *
</span>   497    <span class="xdoc">     *  This gate is also used to protect MessageQ when growing
</span>   498    <span class="xdoc">     *  internal tables in the {<b>@link</b> #create}.
</span>   499    <span class="xdoc">     *
</span>   500    <span class="xdoc">     *  The table is in local memory, not shared memory. So a
</span>   501    <span class="xdoc">     *  single processor gate will work.
</span>   502    <span class="xdoc">     *
</span>   503    <span class="xdoc">     *  The default will be {<b>@link</b> xdc.runtime.knl.GateThread}
</span>   504    <span class="xdoc">     *  instance.
</span>   505    <span class="xdoc">     */</span>
   506        <span class=key>config</span> IGateProvider.Handle nameTableGate = <span class=key>null</span>;
   507        
   508        <span class="xdoc">/*! 
</span>   509    <span class="xdoc">     *  Maximum length for Message queue names
</span>   510    <span class="xdoc">     */</span>
   511        <span class=key>config</span> UInt maxNameLen = 32;
   512    
   513        <span class="xdoc">/*! 
</span>   514    <span class="xdoc">     *  Section name is used to place the names table
</span>   515    <span class="xdoc">     */</span>
   516        <span class=key>metaonly</span> <span class=key>config</span> String tableSection = <span class=key>null</span>;
   517        
   518        <span class="xdoc">/*!
</span>   519    <span class="xdoc">     *  ======== registerHeapMeta ========
</span>   520    <span class="xdoc">     *  Statically register a heap with MessageQ
</span>   521    <span class="xdoc">     *
</span>   522    <span class="xdoc">     *  Build error if heapId is in use.
</span>   523    <span class="xdoc">     *
</span>   524    <span class="xdoc">     *  <b>@param(heap)</b>        Heap to register
</span>   525    <span class="xdoc">     *  <b>@param(heapId)</b>      heapId associated with the heap
</span>   526    <span class="xdoc">     */</span>
   527        <span class=key>metaonly</span> Void registerHeapMeta(IHeap.Handle heap, UInt16 heapId);
   528         
   529         <span class="xdoc">/*!
</span>   530    <span class="xdoc">     *  ======== registerTransportMeta ========
</span>   531    <span class="xdoc">     *  Statically register a transport with MessageQ
</span>   532    <span class="xdoc">     *
</span>   533    <span class="xdoc">     *  Build error if remote processor already has a transport
</span>   534    <span class="xdoc">     *  registered.
</span>   535    <span class="xdoc">     *
</span>   536    <span class="xdoc">     *  <b>@param(transport)</b>   transport to register
</span>   537    <span class="xdoc">     *  <b>@param(procId)</b>      procId that transport communicaties with
</span>   538    <span class="xdoc">     *  <b>@param(priority)</b>    priority of transport
</span>   539    <span class="xdoc">     */</span>
   540         <span class=key>metaonly</span> Void registerTransportMeta(IMessageQTransport.Handle transport, UInt16 procId, UInt priority);
   541         
   542        <span class="xdoc">/*!
</span>   543    <span class="xdoc">     *  ======== registerTransport ========
</span>   544    <span class="xdoc">     *  Register a transport with MessageQ
</span>   545    <span class="xdoc">     *
</span>   546    <span class="xdoc">     *  This API is called by the transport when it is created.
</span>   547    <span class="xdoc">     *
</span>   548    <span class="xdoc">     *  <b>@param(transport)</b>   transport to register
</span>   549    <span class="xdoc">     *  <b>@param(procId)</b>      MultiProc id that transport communicates with
</span>   550    <span class="xdoc">     *  <b>@param(priority)</b>    priority of transport
</span>   551    <span class="xdoc">     *
</span>   552    <span class="xdoc">     *  <b>@b(returns)</b>         Whether the register was successful.
</span>   553    <span class="xdoc">     */</span>
   554        Bool registerTransport(IMessageQTransport.Handle transport, UInt16 procId,
   555            UInt priority);
   556    
   557        <span class="xdoc">/*!
</span>   558    <span class="xdoc">     *  ======== unregisterTransport ========
</span>   559    <span class="xdoc">     *  Unregister a transport with MessageQ
</span>   560    <span class="xdoc">     *
</span>   561    <span class="xdoc">     *  <b>@param(procId)</b>      unregister transport that communicates with
</span>   562    <span class="xdoc">     *                      this remote processor
</span>   563    <span class="xdoc">     *  <b>@param(priority)</b>    priority of transport
</span>   564    <span class="xdoc">     */</span>
   565        Void unregisterTransport(UInt16 procId, UInt priority);
   566        
   567    <span class=key>instance</span>:
   568      
   569        <span class="xdoc">/*! 
</span>   570    <span class="xdoc">     *  ISync handle used to signal IO completion 
</span>   571    <span class="xdoc">     *
</span>   572    <span class="xdoc">     *  The ISync instance is used in the {<b>@link</b> #get} and {<b>@link</b> #put}.
</span>   573    <span class="xdoc">     *  The {<b>@link</b> xdc.runtime.knl.ISync#signal} is called as part
</span>   574    <span class="xdoc">     *  of the {<b>@link</b> #put} call.  The {<b>@link</b> xdc.runtime.knl.ISync#wait} is 
</span>   575    <span class="xdoc">     *  called in the {<b>@link</b> #get} if there are no messages present.
</span>   576    <span class="xdoc">     */</span>
   577        <span class=key>config</span> ISync.Handle synchronizer = <span class=key>null</span>;
   578        
   579        <span class="xdoc">/*! <b>@_nodoc</b>
</span>   580    <span class="xdoc">     *  ======== create ========
</span>   581    <span class="xdoc">     *  Create a message queue
</span>   582    <span class="xdoc">     *
</span>   583    <span class="xdoc">     *  <b>@param(name)</b>         Name of the message queue.
</span>   584    <span class="xdoc">     */</span>
   585        create(String name);   
   586        
   587    <span class=key>internal</span>:
   588        <span class="comment">/* 
</span>   589    <span class="comment">     *  The following describes the usage of the flag field     
</span>   590    <span class="comment">     *  ---------------------------------
</span>   591    <span class="comment">     *  |V V V|T|     reserved      |P P|
</span>   592    <span class="comment">     *  ---------------------------------
</span>   593    <span class="comment">     *   E D C B A 0 9 8 7 6 5 4 3 2 1 0
</span>   594    <span class="comment">     *     
</span>   595    <span class="comment">     *  V = version
</span>   596    <span class="comment">     *  P = priority
</span>   597    <span class="comment">     *  T = trace flag
</span>   598    <span class="comment">     */</span>
   599    
   600        <span class="xdoc">/*! Mask to extract version setting */</span>
   601        <span class=key>const</span> UInt VERSIONMASK = 0xE000;
   602        
   603        <span class="xdoc">/*! Version setting */</span>
   604        <span class=key>const</span> UInt HEADERVERSION = 0x2000;
   605        
   606        <span class="xdoc">/*! Mask to extract Trace setting */</span>
   607        <span class=key>const</span> UInt TRACEMASK = 0x1000;
   608        
   609        <span class="xdoc">/*! Shift for Trace setting */</span>
   610        <span class=key>const</span> UInt TRACESHIFT = 12;
   611           
   612        <span class="xdoc">/*!
</span>   613    <span class="xdoc">     *  Mask to extract priority setting.
</span>   614    <span class="xdoc">     *  This is needed here for ROV but must match
</span>   615    <span class="xdoc">     *  the value defined in ti/ipc/MessageQ.h
</span>   616    <span class="xdoc">     */</span>
   617        <span class=key>const</span> UInt PRIORITYMASK = 0x3;
   618        
   619        <span class="xdoc">/*! Mask to extract priority setting */</span>
   620        <span class=key>const</span> UInt TRANSPORTPRIORITYMASK = 0x1;
   621            
   622         <span class="xdoc">/*! return code for Instance_init */</span>
   623        <span class=key>const</span> Int PROXY_FAILURE = 1;
   624    
   625        <span class="comment">/* 
</span>   626    <span class="comment">     *  Used to denote a message that was initialized 
</span>   627    <span class="comment">     *  with the MessageQ_staticMsgInit function.
</span>   628    <span class="comment">     */</span>
   629        <span class=key>const</span> UInt16 STATICMSG = 0xFFFF;
   630    
   631        <span class="xdoc">/*! Required first field in every message */</span>
   632        @Opaque <span class=key>struct</span> MsgHeader {
   633            Bits32       reserved0;         <span class="comment">/* reserved for List.elem-&gt;next */</span>
   634            Bits32       reserved1;         <span class="comment">/* reserved for List.elem-&gt;prev */</span>
   635            Bits32       msgSize;           <span class="comment">/* message size                 */</span>
   636            Bits16       flags;             <span class="comment">/* bitmask of different flags   */</span>
   637            Bits16       msgId;             <span class="comment">/* message id                   */</span>
   638            Bits16       dstId;             <span class="comment">/* destination processor id     */</span>
   639            Bits16       dstProc;           <span class="comment">/* destination processor        */</span>
   640            Bits16       replyId;           <span class="comment">/* reply id                     */</span>
   641            Bits16       replyProc;         <span class="comment">/* reply processor              */</span>
   642            Bits16       srcProc;           <span class="comment">/* source processor             */</span>
   643            Bits16       heapId;            <span class="comment">/* heap id                      */</span>
   644            Bits16       seqNum;            <span class="comment">/* sequence number              */</span>
   645            Bits16       reserved;          <span class="comment">/* reserved                     */</span>
   646        };
   647        
   648        <span class=key>struct</span> HeapEntry {
   649            IHeap.Handle  heap;
   650            UInt16        heapId;
   651        };
   652        
   653        <span class=key>struct</span> TransportEntry {
   654            IMessageQTransport.Handle  transport;
   655            UInt16             procId;
   656        };
   657        
   658        <span class="xdoc">/*! 
</span>   659    <span class="xdoc">     *  ======== nameSrvPrms ========
</span>   660    <span class="xdoc">     *  This Params object is used for temporary storage of the
</span>   661    <span class="xdoc">     *  module wide parameters that are for setting the NameServer instance.
</span>   662    <span class="xdoc">     */</span>
   663        <span class=key>metaonly</span> <span class=key>config</span> NameServer.Params nameSrvPrms;
   664        
   665        <span class="xdoc">/*! 
</span>   666    <span class="xdoc">     *  Statically registered heaps
</span>   667    <span class="xdoc">     *
</span>   668    <span class="xdoc">     *  This configuration parameter allows the static registeration
</span>   669    <span class="xdoc">     *  of heaps. The index of the array corresponds to the heapId.     
</span>   670    <span class="xdoc">     */</span>
   671        <span class=key>metaonly</span> <span class=key>config</span> HeapEntry staticHeaps[];
   672        
   673        <span class="xdoc">/*! 
</span>   674    <span class="xdoc">     *  Statically registered transports
</span>   675    <span class="xdoc">     *
</span>   676    <span class="xdoc">     *  This configuration parameter allows the static registeration
</span>   677    <span class="xdoc">     *  of transports. The index of the array corresponds to the procId.     
</span>   678    <span class="xdoc">     */</span>
   679        <span class=key>metaonly</span> <span class=key>config</span> TransportEntry staticTransports[];
   680        
   681        <span class="xdoc">/*!
</span>   682    <span class="xdoc">     *  Allows for the number of dynamically created message queues to grow.
</span>   683    <span class="xdoc">     */</span>
   684        UInt16 grow(Object *obj, Error.Block *eb);
   685      
   686        <span class=key>struct</span> Instance_State {
   687            QueueId         queue;        <span class="comment">/* Unique id                     */</span>
   688            ISync.Handle    synchronizer; <span class="comment">/* completion synchronizer       */</span>
   689            List.Object     normalList;   <span class="comment">/* Embedded List objects         */</span>
   690            List.Object     highList;     <span class="comment">/* Embedded List objects         */</span>
   691            Ptr             nsKey;        <span class="comment">/* unique NameServer key         */</span>
   692            SyncSem.Handle  syncSemHandle;<span class="comment">/* for use in finalize           */</span>
   693            Bool            unblocked;    <span class="comment">/* Whether MessageQ is unblocked */</span>
   694        };
   695      
   696        <span class=key>struct</span> Module_State {        
   697            IMessageQTransport.Handle transports[][2];
   698            Handle               queues[];        
   699            IHeap.Handle         heaps[];        
   700            IGateProvider.Handle gate;
   701            UInt16               numQueues;
   702            UInt16               numHeaps;        
   703            NameServer.Handle    nameServer;
   704            Bool                 canFreeQueues;
   705            UInt16               seqNum;
   706        };
   707    } 
</pre>
</body></html>
